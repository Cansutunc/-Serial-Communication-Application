CCS PCM C Compiler, Version 5.015, 5967               18-May-21 00:26

               Filename:   C:\Users\asus\Desktop\Microcontrollers experiment4\CASE1\Case_2 procedure_2\case_1 procedure_2reader.lst

               ROM used:   1213 words (15%)
                           Largest free fragment is 2048
               RAM used:   24 (7%) at main() level
                           42 (11%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   3B4
0003:  NOP
.................... #include<16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA 4B,38
0005:  DATA 3D,10
0006:  DATA 25,36
0007:  DATA 75,00
0008:  DATA 8C,25
0009:  DATA F0,1E
000A:  DATA 25,36
000B:  DATA 75,00
000C:  DATA A0,25
000D:  DATA E9,1E
000E:  DATA 25,36
000F:  DATA 75,00
0010:  DATA 8C,25
0011:  DATA E9,1E
0012:  DATA 25,36
0013:  DATA 75,00
0014:  DATA A0,25
0015:  DATA E4,1E
0016:  DATA 25,36
0017:  DATA 75,00
0018:  DATA 8C,25
0019:  DATA E4,1E
001A:  DATA 25,36
001B:  DATA 75,00
001C:  DATA 8C,25
001D:  DATA F0,1E
001E:  DATA 25,36
001F:  DATA 75,10
0020:  DATA CB,34
0021:  DATA BD,12
0022:  DATA EC,3A
0023:  DATA 20,05
0024:  DATA A0,25
0025:  DATA E4,1E
0026:  DATA 25,36
0027:  DATA 75,00
*
0140:  MOVF   3B,W
0141:  XORWF  3D,W
0142:  ANDLW  80
0143:  MOVWF  3F
0144:  BTFSS  3B.7
0145:  GOTO   14B
0146:  COMF   3A,F
0147:  COMF   3B,F
0148:  INCF   3A,F
0149:  BTFSC  03.2
014A:  INCF   3B,F
014B:  BTFSS  3D.7
014C:  GOTO   152
014D:  COMF   3C,F
014E:  COMF   3D,F
014F:  INCF   3C,F
0150:  BTFSC  03.2
0151:  INCF   3D,F
0152:  MOVLW  10
0153:  MOVWF  3E
0154:  CLRF   77
0155:  CLRF   7A
0156:  RRF    3B,F
0157:  RRF    3A,F
0158:  BTFSS  03.0
0159:  GOTO   160
015A:  MOVF   3C,W
015B:  ADDWF  77,F
015C:  BTFSC  03.0
015D:  INCF   7A,F
015E:  MOVF   3D,W
015F:  ADDWF  7A,F
0160:  RRF    7A,F
0161:  RRF    77,F
0162:  RRF    79,F
0163:  RRF    78,F
0164:  DECFSZ 3E,F
0165:  GOTO   156
0166:  BTFSS  3F.7
0167:  GOTO   16D
0168:  COMF   78,F
0169:  COMF   79,F
016A:  INCF   78,F
016B:  BTFSC  03.2
016C:  INCF   79,F
*
0201:  MOVF   0B,W
0202:  MOVWF  33
0203:  BCF    0B.7
0204:  BSF    03.5
0205:  BSF    03.6
0206:  BSF    0C.7
0207:  BSF    0C.0
0208:  NOP
0209:  NOP
020A:  BCF    03.5
020B:  BCF    03.6
020C:  BTFSC  33.7
020D:  BSF    0B.7
020E:  BTFSC  03.0
020F:  GOTO   239
0210:  BSF    03.6
0211:  MOVF   0C,W
0212:  ANDLW  7F
0213:  BCF    03.6
0214:  MOVWF  33
0215:  BSF    03.6
0216:  MOVF   0D,W
0217:  BCF    03.6
0218:  MOVWF  34
0219:  BSF    03.6
021A:  MOVF   0F,W
021B:  BCF    03.6
021C:  MOVWF  35
021D:  MOVF   33,W
021E:  BTFSS  0C.4
021F:  GOTO   21E
0220:  MOVWF  19
0221:  MOVF   34,W
0222:  BSF    03.6
0223:  MOVWF  0D
0224:  BCF    03.6
0225:  MOVF   35,W
0226:  BSF    03.6
0227:  MOVWF  0F
0228:  BCF    03.6
0229:  MOVF   0B,W
022A:  MOVWF  36
022B:  BCF    0B.7
022C:  BSF    03.5
022D:  BSF    03.6
022E:  BSF    0C.7
022F:  BSF    0C.0
0230:  NOP
0231:  NOP
0232:  BCF    03.5
0233:  BCF    03.6
0234:  BTFSC  36.7
0235:  BSF    0B.7
0236:  DECFSZ 32,F
0237:  GOTO   239
0238:  GOTO   259
0239:  BSF    03.6
023A:  RLF    0C,W
023B:  RLF    0E,W
023C:  ANDLW  7F
023D:  BCF    03.6
023E:  MOVWF  33
023F:  BSF    03.6
0240:  MOVF   0D,W
0241:  BCF    03.6
0242:  MOVWF  34
0243:  BSF    03.6
0244:  MOVF   0F,W
0245:  BCF    03.6
0246:  MOVWF  35
0247:  MOVF   33,W
0248:  BTFSS  0C.4
0249:  GOTO   248
024A:  MOVWF  19
024B:  MOVF   34,W
024C:  BSF    03.6
024D:  MOVWF  0D
024E:  BCF    03.6
024F:  MOVF   35,W
0250:  BSF    03.6
0251:  MOVWF  0F
0252:  INCF   0D,F
0253:  BTFSC  03.2
0254:  INCF   0F,F
0255:  BCF    03.0
0256:  BCF    03.6
0257:  DECFSZ 32,F
0258:  GOTO   201
0259:  RETURN
025A:  CLRF   3A
025B:  MOVF   04,W
025C:  MOVWF  39
025D:  BCF    3A.0
025E:  BTFSC  03.7
025F:  BSF    3A.0
0260:  SWAPF  33,W
0261:  IORLW  F0
0262:  MOVWF  35
0263:  ADDWF  35,F
0264:  ADDLW  E2
0265:  MOVWF  36
0266:  ADDLW  32
0267:  MOVWF  38
0268:  MOVF   33,W
0269:  ANDLW  0F
026A:  ADDWF  36,F
026B:  ADDWF  36,F
026C:  ADDWF  38,F
026D:  ADDLW  E9
026E:  MOVWF  37
026F:  ADDWF  37,F
0270:  ADDWF  37,F
0271:  SWAPF  32,W
0272:  ANDLW  0F
0273:  ADDWF  37,F
0274:  ADDWF  38,F
0275:  RLF    37,F
0276:  RLF    38,F
0277:  COMF   38,F
0278:  RLF    38,F
0279:  MOVF   32,W
027A:  ANDLW  0F
027B:  ADDWF  38,F
027C:  RLF    35,F
027D:  MOVLW  07
027E:  MOVWF  34
027F:  MOVLW  0A
0280:  ADDWF  38,F
0281:  DECF   37,F
0282:  BTFSS  03.0
0283:  GOTO   280
0284:  ADDWF  37,F
0285:  DECF   36,F
0286:  BTFSS  03.0
0287:  GOTO   284
0288:  ADDWF  36,F
0289:  DECF   35,F
028A:  BTFSS  03.0
028B:  GOTO   288
028C:  ADDWF  35,F
028D:  DECF   34,F
028E:  BTFSS  03.0
028F:  GOTO   28C
0290:  MOVLW  34
0291:  MOVWF  04
0292:  BCF    03.7
0293:  MOVLW  07
0294:  ANDWF  39,W
0295:  BCF    39.6
0296:  ADDWF  04,F
0297:  MOVLW  38
0298:  SUBWF  04,W
0299:  BTFSC  03.2
029A:  BSF    39.6
029B:  MOVF   00,W
029C:  MOVWF  77
029D:  BTFSS  03.2
029E:  GOTO   2A7
029F:  BTFSC  39.6
02A0:  GOTO   2A7
02A1:  BTFSC  39.4
02A2:  GOTO   2AF
02A3:  BTFSC  39.3
02A4:  GOTO   2A7
02A5:  MOVLW  20
02A6:  GOTO   2AA
02A7:  BSF    39.3
02A8:  BCF    39.4
02A9:  MOVLW  30
02AA:  ADDWF  77,F
02AB:  MOVF   77,W
02AC:  BTFSS  0C.4
02AD:  GOTO   2AC
02AE:  MOVWF  19
02AF:  INCF   04,F
02B0:  BTFSS  39.6
02B1:  GOTO   297
02B2:  RETURN
*
02F1:  MOVF   0B,W
02F2:  MOVWF  33
02F3:  BCF    0B.7
02F4:  BSF    03.5
02F5:  BSF    03.6
02F6:  BSF    0C.7
02F7:  BSF    0C.0
02F8:  NOP
02F9:  NOP
02FA:  BCF    03.5
02FB:  BCF    03.6
02FC:  BTFSC  33.7
02FD:  BSF    0B.7
02FE:  BTFSC  03.0
02FF:  GOTO   328
0300:  BSF    03.6
0301:  MOVF   0C,W
0302:  ANDLW  7F
0303:  BCF    03.6
0304:  MOVWF  33
0305:  BSF    03.6
0306:  MOVF   0D,W
0307:  BCF    03.6
0308:  MOVWF  34
0309:  BSF    03.6
030A:  MOVF   0F,W
030B:  BCF    03.6
030C:  MOVWF  35
030D:  MOVF   33,W
030E:  MOVWF  3B
030F:  CALL   2C5
0310:  MOVF   34,W
0311:  BSF    03.6
0312:  MOVWF  0D
0313:  BCF    03.6
0314:  MOVF   35,W
0315:  BSF    03.6
0316:  MOVWF  0F
0317:  BCF    03.6
0318:  MOVF   0B,W
0319:  MOVWF  36
031A:  BCF    0B.7
031B:  BSF    03.5
031C:  BSF    03.6
031D:  BSF    0C.7
031E:  BSF    0C.0
031F:  NOP
0320:  NOP
0321:  BCF    03.5
0322:  BCF    03.6
0323:  BTFSC  36.7
0324:  BSF    0B.7
0325:  DECFSZ 32,F
0326:  GOTO   328
0327:  GOTO   347
0328:  BSF    03.6
0329:  RLF    0C,W
032A:  RLF    0E,W
032B:  ANDLW  7F
032C:  BCF    03.6
032D:  MOVWF  33
032E:  BSF    03.6
032F:  MOVF   0D,W
0330:  BCF    03.6
0331:  MOVWF  34
0332:  BSF    03.6
0333:  MOVF   0F,W
0334:  BCF    03.6
0335:  MOVWF  35
0336:  MOVF   33,W
0337:  MOVWF  3B
0338:  CALL   2C5
0339:  MOVF   34,W
033A:  BSF    03.6
033B:  MOVWF  0D
033C:  BCF    03.6
033D:  MOVF   35,W
033E:  BSF    03.6
033F:  MOVWF  0F
0340:  INCF   0D,F
0341:  BTFSC  03.2
0342:  INCF   0F,F
0343:  BCF    03.0
0344:  BCF    03.6
0345:  DECFSZ 32,F
0346:  GOTO   2F1
0347:  RETURN
0348:  CLRF   3A
0349:  MOVF   04,W
034A:  MOVWF  39
034B:  BCF    3A.0
034C:  BTFSC  03.7
034D:  BSF    3A.0
034E:  SWAPF  33,W
034F:  IORLW  F0
0350:  MOVWF  35
0351:  ADDWF  35,F
0352:  ADDLW  E2
0353:  MOVWF  36
0354:  ADDLW  32
0355:  MOVWF  38
0356:  MOVF   33,W
0357:  ANDLW  0F
0358:  ADDWF  36,F
0359:  ADDWF  36,F
035A:  ADDWF  38,F
035B:  ADDLW  E9
035C:  MOVWF  37
035D:  ADDWF  37,F
035E:  ADDWF  37,F
035F:  SWAPF  32,W
0360:  ANDLW  0F
0361:  ADDWF  37,F
0362:  ADDWF  38,F
0363:  RLF    37,F
0364:  RLF    38,F
0365:  COMF   38,F
0366:  RLF    38,F
0367:  MOVF   32,W
0368:  ANDLW  0F
0369:  ADDWF  38,F
036A:  RLF    35,F
036B:  MOVLW  07
036C:  MOVWF  34
036D:  MOVLW  0A
036E:  ADDWF  38,F
036F:  DECF   37,F
0370:  BTFSS  03.0
0371:  GOTO   36E
0372:  ADDWF  37,F
0373:  DECF   36,F
0374:  BTFSS  03.0
0375:  GOTO   372
0376:  ADDWF  36,F
0377:  DECF   35,F
0378:  BTFSS  03.0
0379:  GOTO   376
037A:  ADDWF  35,F
037B:  DECF   34,F
037C:  BTFSS  03.0
037D:  GOTO   37A
037E:  MOVLW  34
037F:  MOVWF  04
0380:  BCF    03.7
0381:  MOVLW  07
0382:  ANDWF  39,W
0383:  BCF    39.6
0384:  ADDWF  04,F
0385:  MOVLW  38
0386:  SUBWF  04,W
0387:  BTFSC  03.2
0388:  BSF    39.6
0389:  MOVF   00,W
038A:  MOVWF  77
038B:  BTFSS  03.2
038C:  GOTO   395
038D:  BTFSC  39.6
038E:  GOTO   395
038F:  BTFSC  39.4
0390:  GOTO   3A7
0391:  BTFSC  39.3
0392:  GOTO   395
0393:  MOVLW  20
0394:  GOTO   398
0395:  BSF    39.3
0396:  BCF    39.4
0397:  MOVLW  30
0398:  ADDWF  77,F
0399:  CLRF   33
039A:  MOVF   04,W
039B:  MOVWF  32
039C:  BCF    33.0
039D:  BTFSC  03.7
039E:  BSF    33.0
039F:  MOVF   77,W
03A0:  MOVWF  3B
03A1:  CALL   2C5
03A2:  MOVF   32,W
03A3:  MOVWF  04
03A4:  BCF    03.7
03A5:  BTFSC  33.0
03A6:  BSF    03.7
03A7:  INCF   04,F
03A8:  BTFSS  39.6
03A9:  GOTO   385
03AA:  RETURN
03AB:  MOVF   78,W
03AC:  BTFSC  03.2
03AD:  GOTO   3B3
03AE:  MOVF   77,W
03AF:  MOVWF  00
03B0:  INCF   04,F
03B1:  DECFSZ 78,F
03B2:  GOTO   3AE
03B3:  RETURN
....................  
.................... #list 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
03CF:  BCF    03.5
03D0:  CLRF   20
03D1:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
00CD:  CLRF   38
....................    sign = 0; 
00CE:  CLRF   36
....................    base = 10; 
00CF:  MOVLW  0A
00D0:  MOVWF  37
....................    result = 0; 
00D1:  CLRF   35
00D2:  CLRF   34
....................  
....................    if (!s) 
00D3:  MOVF   32,W
00D4:  IORWF  33,W
00D5:  BTFSS  03.2
00D6:  GOTO   0DB
....................       return 0; 
00D7:  MOVLW  00
00D8:  MOVWF  78
00D9:  MOVWF  79
00DA:  GOTO   200
....................    c = s[index++]; 
00DB:  MOVF   38,W
00DC:  INCF   38,F
00DD:  ADDWF  32,W
00DE:  MOVWF  04
00DF:  BCF    03.7
00E0:  BTFSC  33.0
00E1:  BSF    03.7
00E2:  MOVF   00,W
00E3:  MOVWF  39
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
00E4:  MOVF   39,W
00E5:  SUBLW  2D
00E6:  BTFSS  03.2
00E7:  GOTO   0F4
....................    { 
....................       sign = 1;         // Set the sign to negative 
00E8:  MOVLW  01
00E9:  MOVWF  36
....................       c = s[index++]; 
00EA:  MOVF   38,W
00EB:  INCF   38,F
00EC:  ADDWF  32,W
00ED:  MOVWF  04
00EE:  BCF    03.7
00EF:  BTFSC  33.0
00F0:  BSF    03.7
00F1:  MOVF   00,W
00F2:  MOVWF  39
....................    } 
00F3:  GOTO   101
....................    else if (c == '+') 
00F4:  MOVF   39,W
00F5:  SUBLW  2B
00F6:  BTFSS  03.2
00F7:  GOTO   101
....................    { 
....................       c = s[index++]; 
00F8:  MOVF   38,W
00F9:  INCF   38,F
00FA:  ADDWF  32,W
00FB:  MOVWF  04
00FC:  BCF    03.7
00FD:  BTFSC  33.0
00FE:  BSF    03.7
00FF:  MOVF   00,W
0100:  MOVWF  39
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0101:  MOVF   39,W
0102:  SUBLW  2F
0103:  BTFSC  03.0
0104:  GOTO   1F1
0105:  MOVF   39,W
0106:  SUBLW  39
0107:  BTFSS  03.0
0108:  GOTO   1F1
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0109:  MOVF   39,W
010A:  SUBLW  30
010B:  BTFSS  03.2
010C:  GOTO   12D
010D:  MOVF   38,W
010E:  ADDWF  32,W
010F:  MOVWF  04
0110:  BCF    03.7
0111:  BTFSC  33.0
0112:  BSF    03.7
0113:  MOVF   00,W
0114:  SUBLW  78
0115:  BTFSC  03.2
0116:  GOTO   121
0117:  MOVF   38,W
0118:  ADDWF  32,W
0119:  MOVWF  04
011A:  BCF    03.7
011B:  BTFSC  33.0
011C:  BSF    03.7
011D:  MOVF   00,W
011E:  SUBLW  58
011F:  BTFSS  03.2
0120:  GOTO   12D
....................       { 
....................          base = 16; 
0121:  MOVLW  10
0122:  MOVWF  37
....................          index++; 
0123:  INCF   38,F
....................          c = s[index++]; 
0124:  MOVF   38,W
0125:  INCF   38,F
0126:  ADDWF  32,W
0127:  MOVWF  04
0128:  BCF    03.7
0129:  BTFSC  33.0
012A:  BSF    03.7
012B:  MOVF   00,W
012C:  MOVWF  39
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
012D:  MOVF   37,W
012E:  SUBLW  0A
012F:  BTFSS  03.2
0130:  GOTO   180
....................       { 
....................          while (c >= '0' && c <= '9') 
0131:  MOVF   39,W
0132:  SUBLW  2F
0133:  BTFSC  03.0
0134:  GOTO   17F
0135:  MOVF   39,W
0136:  SUBLW  39
0137:  BTFSS  03.0
0138:  GOTO   17F
....................          { 
....................             result = 10*result + (c - '0'); 
0139:  CLRF   3B
013A:  MOVLW  0A
013B:  MOVWF  3A
013C:  MOVF   35,W
013D:  MOVWF  3D
013E:  MOVF   34,W
013F:  MOVWF  3C
*
016D:  MOVLW  30
016E:  SUBWF  39,W
016F:  ADDWF  78,W
0170:  MOVWF  34
0171:  MOVF   79,W
0172:  MOVWF  35
0173:  BTFSC  03.0
0174:  INCF   35,F
....................             c = s[index++]; 
0175:  MOVF   38,W
0176:  INCF   38,F
0177:  ADDWF  32,W
0178:  MOVWF  04
0179:  BCF    03.7
017A:  BTFSC  33.0
017B:  BSF    03.7
017C:  MOVF   00,W
017D:  MOVWF  39
017E:  GOTO   131
....................          } 
....................       } 
017F:  GOTO   1F1
....................       else if (base == 16)    // The number is a hexa number 
0180:  MOVF   37,W
0181:  SUBLW  10
0182:  BTFSS  03.2
0183:  GOTO   1F1
....................       { 
....................          c = toupper(c); 
0184:  MOVF   39,W
0185:  SUBLW  60
0186:  BTFSC  03.0
0187:  GOTO   18F
0188:  MOVF   39,W
0189:  SUBLW  7A
018A:  BTFSS  03.0
018B:  GOTO   18F
018C:  MOVF   39,W
018D:  ANDLW  DF
018E:  GOTO   190
018F:  MOVF   39,W
0190:  MOVWF  39
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0191:  MOVF   39,W
0192:  SUBLW  2F
0193:  BTFSC  03.0
0194:  GOTO   199
0195:  MOVF   39,W
0196:  SUBLW  39
0197:  BTFSC  03.0
0198:  GOTO   1A1
0199:  MOVF   39,W
019A:  SUBLW  40
019B:  BTFSC  03.0
019C:  GOTO   1F1
019D:  MOVF   39,W
019E:  SUBLW  46
019F:  BTFSS  03.0
01A0:  GOTO   1F1
....................          { 
....................             if (c >= '0' && c <= '9') 
01A1:  MOVF   39,W
01A2:  SUBLW  2F
01A3:  BTFSC  03.0
01A4:  GOTO   1C2
01A5:  MOVF   39,W
01A6:  SUBLW  39
01A7:  BTFSS  03.0
01A8:  GOTO   1C2
....................                result = (result << 4) + (c - '0'); 
01A9:  RLF    34,W
01AA:  MOVWF  3A
01AB:  RLF    35,W
01AC:  MOVWF  3B
01AD:  RLF    3A,F
01AE:  RLF    3B,F
01AF:  RLF    3A,F
01B0:  RLF    3B,F
01B1:  RLF    3A,F
01B2:  RLF    3B,F
01B3:  MOVLW  F0
01B4:  ANDWF  3A,F
01B5:  MOVLW  30
01B6:  SUBWF  39,W
01B7:  ADDWF  3A,W
01B8:  MOVWF  78
01B9:  MOVF   3B,W
01BA:  MOVWF  7A
01BB:  BTFSC  03.0
01BC:  INCF   7A,F
01BD:  MOVF   78,W
01BE:  MOVWF  34
01BF:  MOVF   7A,W
01C0:  MOVWF  35
01C1:  GOTO   1DB
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
01C2:  RLF    34,W
01C3:  MOVWF  3A
01C4:  RLF    35,W
01C5:  MOVWF  3B
01C6:  RLF    3A,F
01C7:  RLF    3B,F
01C8:  RLF    3A,F
01C9:  RLF    3B,F
01CA:  RLF    3A,F
01CB:  RLF    3B,F
01CC:  MOVLW  F0
01CD:  ANDWF  3A,F
01CE:  MOVLW  41
01CF:  SUBWF  39,W
01D0:  ADDLW  0A
01D1:  ADDWF  3A,W
01D2:  MOVWF  78
01D3:  MOVF   3B,W
01D4:  MOVWF  7A
01D5:  BTFSC  03.0
01D6:  INCF   7A,F
01D7:  MOVF   78,W
01D8:  MOVWF  34
01D9:  MOVF   7A,W
01DA:  MOVWF  35
....................  
....................             c = s[index++];c = toupper(c); 
01DB:  MOVF   38,W
01DC:  INCF   38,F
01DD:  ADDWF  32,W
01DE:  MOVWF  04
01DF:  BCF    03.7
01E0:  BTFSC  33.0
01E1:  BSF    03.7
01E2:  MOVF   00,W
01E3:  MOVWF  39
01E4:  SUBLW  60
01E5:  BTFSC  03.0
01E6:  GOTO   1EE
01E7:  MOVF   39,W
01E8:  SUBLW  7A
01E9:  BTFSS  03.0
01EA:  GOTO   1EE
01EB:  MOVF   39,W
01EC:  ANDLW  DF
01ED:  GOTO   1EF
01EE:  MOVF   39,W
01EF:  MOVWF  39
01F0:  GOTO   191
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
01F1:  MOVF   37,W
01F2:  SUBLW  0A
01F3:  BTFSS  03.2
01F4:  GOTO   1FC
01F5:  DECFSZ 36,W
01F6:  GOTO   1FC
....................       result = -result; 
01F7:  COMF   34,F
01F8:  COMF   35,F
01F9:  INCF   34,F
01FA:  BTFSC  03.2
01FB:  INCF   35,F
....................  
....................    return(result); 
01FC:  MOVF   34,W
01FD:  MOVWF  78
01FE:  MOVF   35,W
01FF:  MOVWF  79
0200:  RETURN
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #FUSES XT,NOWDT,NOPROTECT,NOBROWNOUT,NOLVP,NOLVP,NOPUT,NODEBUG,NOCPD 
.................... #use delay(crystal=4000000) 
*
0028:  MOVLW  3C
0029:  MOVWF  04
002A:  BCF    03.7
002B:  MOVF   00,W
002C:  BTFSC  03.2
002D:  GOTO   03C
002E:  MOVLW  01
002F:  MOVWF  78
0030:  CLRF   77
0031:  DECFSZ 77,F
0032:  GOTO   031
0033:  DECFSZ 78,F
0034:  GOTO   030
0035:  MOVLW  4A
0036:  MOVWF  77
0037:  DECFSZ 77,F
0038:  GOTO   037
0039:  GOTO   03A
003A:  DECFSZ 00,F
003B:  GOTO   02E
003C:  RETURN
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0055:  MOVLW  0F
0056:  BSF    03.5
0057:  ANDWF  08,W
0058:  IORLW  F0
0059:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
005A:  BCF    03.5
005B:  BSF    08.2
....................    delay_cycles(1); 
005C:  NOP
....................    lcd_output_enable(1); 
005D:  BSF    08.0
....................    delay_cycles(1); 
005E:  NOP
....................    high = lcd_read_nibble(); 
005F:  CALL   049
0060:  MOVF   78,W
0061:  MOVWF  43
....................        
....................    lcd_output_enable(0); 
0062:  BCF    08.0
....................    delay_cycles(1); 
0063:  NOP
....................    lcd_output_enable(1); 
0064:  BSF    08.0
....................    delay_us(1); 
0065:  NOP
....................    low = lcd_read_nibble(); 
0066:  CALL   049
0067:  MOVF   78,W
0068:  MOVWF  42
....................        
....................    lcd_output_enable(0); 
0069:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
006A:  MOVLW  0F
006B:  BSF    03.5
006C:  ANDWF  08,W
006D:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
006E:  BCF    03.5
006F:  SWAPF  43,W
0070:  MOVWF  77
0071:  MOVLW  F0
0072:  ANDWF  77,F
0073:  MOVF   77,W
0074:  IORWF  42,W
0075:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0049:  MOVF   08,W
004A:  MOVWF  77
004B:  SWAPF  08,W
004C:  ANDLW  0F
004D:  MOVWF  78
....................   #endif 
004E:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
003D:  SWAPF  43,W
003E:  ANDLW  F0
003F:  MOVWF  77
0040:  MOVLW  0F
0041:  ANDWF  08,W
0042:  IORWF  77,W
0043:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0044:  NOP
....................    lcd_output_enable(1); 
0045:  BSF    08.0
....................    delay_us(2); 
0046:  GOTO   047
....................    lcd_output_enable(0); 
0047:  BCF    08.0
0048:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
004F:  BSF    03.5
0050:  BCF    08.0
....................    lcd_rs_tris(); 
0051:  BCF    08.1
....................    lcd_rw_tris(); 
0052:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0053:  BCF    03.5
0054:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0076:  MOVF   78,W
0077:  MOVWF  42
0078:  BTFSC  42.7
0079:  GOTO   055
....................    lcd_output_rs(address); 
007A:  BTFSS  40.0
007B:  BCF    08.1
007C:  BTFSC  40.0
007D:  BSF    08.1
....................    delay_cycles(1); 
007E:  NOP
....................    lcd_output_rw(0); 
007F:  BCF    08.2
....................    delay_cycles(1); 
0080:  NOP
....................    lcd_output_enable(0); 
0081:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
0082:  SWAPF  41,W
0083:  MOVWF  42
0084:  MOVLW  0F
0085:  ANDWF  42,F
0086:  MOVF   42,W
0087:  MOVWF  43
0088:  CALL   03D
....................    lcd_send_nibble(n & 0xf); 
0089:  MOVF   41,W
008A:  ANDLW  0F
008B:  MOVWF  42
008C:  MOVWF  43
008D:  CALL   03D
008E:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
008F:  MOVLW  28
0090:  MOVWF  33
0091:  MOVLW  0C
0092:  MOVWF  34
0093:  MOVLW  01
0094:  MOVWF  35
0095:  MOVLW  06
0096:  MOVWF  36
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0097:  BCF    08.0
....................    lcd_output_rs(0); 
0098:  BCF    08.1
....................    lcd_output_rw(0); 
0099:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
009A:  MOVLW  0F
009B:  BSF    03.5
009C:  ANDWF  08,W
009D:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
009E:  BCF    08.0
....................    lcd_rs_tris(); 
009F:  BCF    08.1
....................    lcd_rw_tris(); 
00A0:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
00A1:  MOVLW  0F
00A2:  BCF    03.5
00A3:  MOVWF  3C
00A4:  CALL   028
....................    for(i=1;i<=3;++i) 
00A5:  MOVLW  01
00A6:  MOVWF  32
00A7:  MOVF   32,W
00A8:  SUBLW  03
00A9:  BTFSS  03.0
00AA:  GOTO   0B3
....................    { 
....................        lcd_send_nibble(3); 
00AB:  MOVLW  03
00AC:  MOVWF  43
00AD:  CALL   03D
....................        delay_ms(5); 
00AE:  MOVLW  05
00AF:  MOVWF  3C
00B0:  CALL   028
00B1:  INCF   32,F
00B2:  GOTO   0A7
....................    } 
....................     
....................    lcd_send_nibble(2); 
00B3:  MOVLW  02
00B4:  MOVWF  43
00B5:  CALL   03D
....................    delay_ms(5); 
00B6:  MOVLW  05
00B7:  MOVWF  3C
00B8:  CALL   028
....................    for(i=0;i<=3;++i) 
00B9:  CLRF   32
00BA:  MOVF   32,W
00BB:  SUBLW  03
00BC:  BTFSS  03.0
00BD:  GOTO   0CA
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00BE:  MOVLW  33
00BF:  ADDWF  32,W
00C0:  MOVWF  04
00C1:  BCF    03.7
00C2:  MOVF   00,W
00C3:  MOVWF  37
00C4:  CLRF   40
00C5:  MOVF   37,W
00C6:  MOVWF  41
00C7:  CALL   04F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00C8:  INCF   32,F
00C9:  GOTO   0BA
00CA:  BCF    0A.3
00CB:  BCF    0A.4
00CC:  GOTO   3D3 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
02B3:  DECFSZ 3D,W
02B4:  GOTO   2B6
02B5:  GOTO   2B9
....................       address=LCD_LINE_TWO; 
02B6:  MOVLW  40
02B7:  MOVWF  3E
02B8:  GOTO   2BA
....................    else 
....................       address=0; 
02B9:  CLRF   3E
....................       
....................    address+=x-1; 
02BA:  MOVLW  01
02BB:  SUBWF  3C,W
02BC:  ADDWF  3E,F
....................    lcd_send_byte(0,0x80|address); 
02BD:  MOVF   3E,W
02BE:  IORLW  80
02BF:  MOVWF  3F
02C0:  CLRF   40
02C1:  MOVF   3F,W
02C2:  MOVWF  41
02C3:  CALL   04F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02C4:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02C5:  MOVF   3B,W
02C6:  XORLW  07
02C7:  BTFSC  03.2
02C8:  GOTO   2D3
02C9:  XORLW  0B
02CA:  BTFSC  03.2
02CB:  GOTO   2D8
02CC:  XORLW  06
02CD:  BTFSC  03.2
02CE:  GOTO   2E0
02CF:  XORLW  02
02D0:  BTFSC  03.2
02D1:  GOTO   2E6
02D2:  GOTO   2EB
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02D3:  MOVLW  01
02D4:  MOVWF  3C
02D5:  MOVWF  3D
02D6:  CALL   2B3
02D7:  GOTO   2F0
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02D8:  CLRF   40
02D9:  MOVLW  01
02DA:  MOVWF  41
02DB:  CALL   04F
....................                      delay_ms(2); 
02DC:  MOVLW  02
02DD:  MOVWF  3C
02DE:  CALL   028
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02DF:  GOTO   2F0
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02E0:  MOVLW  01
02E1:  MOVWF  3C
02E2:  MOVLW  02
02E3:  MOVWF  3D
02E4:  CALL   2B3
02E5:  GOTO   2F0
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02E6:  CLRF   40
02E7:  MOVLW  10
02E8:  MOVWF  41
02E9:  CALL   04F
02EA:  GOTO   2F0
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02EB:  MOVLW  01
02EC:  MOVWF  40
02ED:  MOVF   3B,W
02EE:  MOVWF  41
02EF:  CALL   04F
....................      #endif 
....................    } 
02F0:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,parity=N,stop=1)  //configuration for serial communication 
.................... int counter = 0;    //counter to be used 
.................... char strlnput[3];  //string array for  input characters 
.................... char j=0; 
.................... unsigned long Kp=0 , Ki=0 , Kd=0 ; 
.................... void main() 
*
03B4:  MOVF   03,W
03B5:  ANDLW  1F
03B6:  MOVWF  03
03B7:  MOVLW  19
03B8:  BSF    03.5
03B9:  MOVWF  19
03BA:  MOVLW  A6
03BB:  MOVWF  18
03BC:  MOVLW  90
03BD:  BCF    03.5
03BE:  MOVWF  18
03BF:  CLRF   26
03C0:  CLRF   2A
03C1:  CLRF   2C
03C2:  CLRF   2B
03C3:  CLRF   2E
03C4:  CLRF   2D
03C5:  CLRF   30
03C6:  CLRF   2F
03C7:  BSF    03.5
03C8:  BSF    1F.0
03C9:  BSF    1F.1
03CA:  BSF    1F.2
03CB:  BCF    1F.3
03CC:  MOVLW  07
03CD:  MOVWF  1C
03CE:  BCF    03.7
.................... { 
.................... lcd_init(); 
*
03D2:  GOTO   08F
.................... delay_ms(10); 
03D3:  MOVLW  0A
03D4:  MOVWF  3C
03D5:  CALL   028
.................... while(1) 
.................... { 
....................   if(kbhit())   //if data has been received 
03D6:  BTFSS  0C.5
03D7:  GOTO   4BB
....................     { 
....................        char j=getc();  //UART read 
03D8:  BTFSS  0C.5
03D9:  GOTO   3D8
03DA:  MOVF   1A,W
03DB:  MOVWF  31
....................        if(j=='P')    //speacial character for serial input. If the received char is P then this condition is called  
03DC:  MOVF   31,W
03DD:  SUBLW  50
03DE:  BTFSS  03.2
03DF:  GOTO   413
....................        {       
....................         Kp=atol(strlnput);  //change string array to long variable 
03E0:  CLRF   33
03E1:  MOVLW  27
03E2:  MOVWF  32
03E3:  CALL   0CD
03E4:  MOVF   79,W
03E5:  MOVWF  2C
03E6:  MOVF   78,W
03E7:  MOVWF  2B
....................         printf("Kp= %lu" ,Kp);  //print inputstring value to the screen 
03E8:  MOVLW  04
03E9:  BSF    03.6
03EA:  MOVWF  0D
03EB:  MOVLW  00
03EC:  MOVWF  0F
03ED:  BCF    03.0
03EE:  MOVLW  04
03EF:  BCF    03.6
03F0:  MOVWF  32
03F1:  CALL   201
03F2:  MOVLW  10
03F3:  MOVWF  04
03F4:  MOVF   2C,W
03F5:  MOVWF  33
03F6:  MOVF   2B,W
03F7:  MOVWF  32
03F8:  CALL   25A
....................         printf(LCD_PUTC,"\fKp=%lu",Kp);  //print PID  values to the lcd 
03F9:  MOVLW  08
03FA:  BSF    03.6
03FB:  MOVWF  0D
03FC:  MOVLW  00
03FD:  MOVWF  0F
03FE:  BCF    03.0
03FF:  MOVLW  04
0400:  BCF    03.6
0401:  MOVWF  32
0402:  CALL   2F1
0403:  MOVLW  10
0404:  MOVWF  04
0405:  MOVF   2C,W
0406:  MOVWF  33
0407:  MOVF   2B,W
0408:  MOVWF  32
0409:  CALL   348
....................         memset(strlnput,0,3); //clear the string array 
040A:  MOVLW  27
040B:  MOVWF  04
040C:  BCF    03.7
040D:  CLRF   77
040E:  MOVLW  03
040F:  MOVWF  78
0410:  CALL   3AB
....................         counter=0;   // counter to be zero again 
0411:  CLRF   26
....................        } 
0412:  GOTO   4BB
....................        else if(j=='I')  //speacial character for serial input. If the received char is I the this condition is called  
0413:  MOVF   31,W
0414:  SUBLW  49
0415:  BTFSS  03.2
0416:  GOTO   44A
....................        { 
....................         Ki=atol(strlnput); //change string array to long variable 
0417:  CLRF   33
0418:  MOVLW  27
0419:  MOVWF  32
041A:  CALL   0CD
041B:  MOVF   79,W
041C:  MOVWF  2E
041D:  MOVF   78,W
041E:  MOVWF  2D
....................         printf(" Ki=%lu" ,Ki);  //print inputstring value to the screen 
041F:  MOVLW  0C
0420:  BSF    03.6
0421:  MOVWF  0D
0422:  MOVLW  00
0423:  MOVWF  0F
0424:  BCF    03.0
0425:  MOVLW  04
0426:  BCF    03.6
0427:  MOVWF  32
0428:  CALL   201
0429:  MOVLW  10
042A:  MOVWF  04
042B:  MOVF   2E,W
042C:  MOVWF  33
042D:  MOVF   2D,W
042E:  MOVWF  32
042F:  CALL   25A
....................         printf(LCD_PUTC,"\fKi=%lu",Ki);  //print PID  values to the lcd 
0430:  MOVLW  10
0431:  BSF    03.6
0432:  MOVWF  0D
0433:  MOVLW  00
0434:  MOVWF  0F
0435:  BCF    03.0
0436:  MOVLW  04
0437:  BCF    03.6
0438:  MOVWF  32
0439:  CALL   2F1
043A:  MOVLW  10
043B:  MOVWF  04
043C:  MOVF   2E,W
043D:  MOVWF  33
043E:  MOVF   2D,W
043F:  MOVWF  32
0440:  CALL   348
....................         memset(strlnput,0,3); //clear the string array 
0441:  MOVLW  27
0442:  MOVWF  04
0443:  BCF    03.7
0444:  CLRF   77
0445:  MOVLW  03
0446:  MOVWF  78
0447:  CALL   3AB
....................         counter=0;   // counter to be zero again 
0448:  CLRF   26
....................        } 
0449:  GOTO   4BB
....................        else if(j=='D')  //speacial character for serial input. If the received char is D the this condition is called  
044A:  MOVF   31,W
044B:  SUBLW  44
044C:  BTFSS  03.2
044D:  GOTO   4B4
....................        { 
....................         Kd=atol(strlnput);  //change string array to long variable 
044E:  CLRF   33
044F:  MOVLW  27
0450:  MOVWF  32
0451:  CALL   0CD
0452:  MOVF   79,W
0453:  MOVWF  30
0454:  MOVF   78,W
0455:  MOVWF  2F
....................         printf(" Kd=%lu" ,Kd);  //print inputstring value to the screen 
0456:  MOVLW  14
0457:  BSF    03.6
0458:  MOVWF  0D
0459:  MOVLW  00
045A:  MOVWF  0F
045B:  BCF    03.0
045C:  MOVLW  04
045D:  BCF    03.6
045E:  MOVWF  32
045F:  CALL   201
0460:  MOVLW  10
0461:  MOVWF  04
0462:  MOVF   30,W
0463:  MOVWF  33
0464:  MOVF   2F,W
0465:  MOVWF  32
0466:  CALL   25A
....................         printf(LCD_PUTC,"\fKd=%lu",Kd);  //print PID  values to the lcd 
0467:  MOVLW  18
0468:  BSF    03.6
0469:  MOVWF  0D
046A:  MOVLW  00
046B:  MOVWF  0F
046C:  BCF    03.0
046D:  MOVLW  04
046E:  BCF    03.6
046F:  MOVWF  32
0470:  CALL   2F1
0471:  MOVLW  10
0472:  MOVWF  04
0473:  MOVF   30,W
0474:  MOVWF  33
0475:  MOVF   2F,W
0476:  MOVWF  32
0477:  CALL   348
....................         memset(strlnput,0,3); //clear the string array 
0478:  MOVLW  27
0479:  MOVWF  04
047A:  BCF    03.7
047B:  CLRF   77
047C:  MOVLW  03
047D:  MOVWF  78
047E:  CALL   3AB
....................         counter=0;   // counter to be zero again       
047F:  CLRF   26
....................         printf(LCD_PUTC,"\fKp=%lu Ki=%lu \n Kd=%lu",Kp,Ki,Kd); 
0480:  MOVLW  1C
0481:  BSF    03.6
0482:  MOVWF  0D
0483:  MOVLW  00
0484:  MOVWF  0F
0485:  BCF    03.0
0486:  MOVLW  04
0487:  BCF    03.6
0488:  MOVWF  32
0489:  CALL   2F1
048A:  MOVLW  10
048B:  MOVWF  04
048C:  MOVF   2C,W
048D:  MOVWF  33
048E:  MOVF   2B,W
048F:  MOVWF  32
0490:  CALL   348
0491:  MOVLW  1F
0492:  BSF    03.6
0493:  MOVWF  0D
0494:  MOVLW  00
0495:  MOVWF  0F
0496:  BSF    03.0
0497:  MOVLW  04
0498:  BCF    03.6
0499:  MOVWF  32
049A:  CALL   2F1
049B:  MOVLW  10
049C:  MOVWF  04
049D:  MOVF   2E,W
049E:  MOVWF  33
049F:  MOVF   2D,W
04A0:  MOVWF  32
04A1:  CALL   348
04A2:  MOVLW  23
04A3:  BSF    03.6
04A4:  MOVWF  0D
04A5:  MOVLW  00
04A6:  MOVWF  0F
04A7:  BCF    03.0
04A8:  MOVLW  06
04A9:  BCF    03.6
04AA:  MOVWF  32
04AB:  CALL   2F1
04AC:  MOVLW  10
04AD:  MOVWF  04
04AE:  MOVF   30,W
04AF:  MOVWF  33
04B0:  MOVF   2F,W
04B1:  MOVWF  32
04B2:  CALL   348
....................        } 
04B3:  GOTO   4BB
....................        else 
....................        { 
....................        strlnput[counter]=j;  //attend input character to the string array 
04B4:  MOVLW  27
04B5:  ADDWF  26,W
04B6:  MOVWF  04
04B7:  BCF    03.7
04B8:  MOVF   31,W
04B9:  MOVWF  00
....................        counter++; //increase the counter by 1. 
04BA:  INCF   26,F
....................        } 
....................    } 
04BB:  GOTO   3D6
....................  } 
.................... } 
....................  
04BC:  SLEEP

Configuration Fuses:
   Word  1: 3F39   XT NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
